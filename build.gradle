gradle.startParameter.showStacktrace = ShowStacktrace.ALWAYS
gradle.startParameter.logLevel = LogLevel.DEBUG
//logging.captureStandardOutput LogLevel.LIFECYCLE

buildscript {
  repositories {
    mavenCentral()
    jcenter()
    maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
  }
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
    classpath "com.satori:satori-libs-gradle-transform:$composerVersion"
    classpath "com.satori:satori-libs-gradle-codegen:$composerVersion"
    classpath "com.satori:satori-gradle-composer-plugin:$composerVersion"

    classpath "com.google.gradle:osdetector-gradle-plugin:+"
  }
}

static String fmtDotNotation(String value) {
  return value.replaceAll(~/[^\w]+/, ".")
}

static String relativePath(File base, File file){
  def delimeters = "/\\"
  List<String> basePath = base.path.tokenize(delimeters)
  List<String> targetPath = file.path.tokenize(delimeters)

  // Find and remove common prefix
  int maxDepth = Math.min(basePath.size(), targetPath.size());
  int prefixLen = 0;
  while (prefixLen < maxDepth && basePath.get(prefixLen).equals(targetPath.get(prefixLen))) {
    prefixLen++;
  }
  basePath = basePath.subList(prefixLen, basePath.size());
  targetPath = targetPath.subList(prefixLen, targetPath.size());

  for (int i = 0; i < basePath.size(); i++) {
    targetPath.add(0, "..");
  }
  if (targetPath.isEmpty()) {
    return ".";
  }
  return CollectionUtils.join(File.separator, targetPath).replace("\\", "/")
}

static String relativePath(Project project, File file){
  return relativePath(project.projectDir, file)
}

allprojects {
  group group
  version version
  buildDir = '.out'
  apply plugin: 'com.google.osdetector'
}

/*apply plugin: "idea"
idea {
  module {
    inheritOutputDirs = false
    outputDir = file(".out/idea")
    testOutputDir = file(".out/idea-tests")
  }
}*/

ext {
  pckg = "$group.${fmtDotNotation(name)}"
  pckgDir = pckg.replace('.', '/')
}

repositories {
  mavenCentral()
}

task clean {
  group "build"
}

task extractProtos(type: Copy) {
  group "codegen"
  def cfg = project.configurations.detachedConfiguration()
  cfg.dependencies.add(dependencies.create(
    "com.google.protobuf:protobuf-java:$protobufVersion"
  ))
  def outDir = file("grpc/include")
  inputs.files cfg
  outputs.file outDir

  from(zipTree(cfg.singleFile)) {
    include "google/protobuf/**/*.proto"
  }
  into outDir

  doFirst {
    from().eachFile {
      logger.lifecycle("copying '${it.path}' to '${relativePath(outDir)}'...")
    }
  }

  clean.doFirst {
    delete outDir
  }
}



task generateProtoIncludesDescriptorSet {
  group "codegen"
  dependsOn extractProtos

  def out = file("$buildDir/grpc-includes.pb")
  def protoDir = file("grpc/include")
  def protoFiles = fileTree(protoDir) {
    include "**/*.proto"
  }

  def cfg = project.configurations.detachedConfiguration()
  cfg.dependencies.add(dependencies.create(
    "com.google.protobuf:protoc:3.5.1:${osdetector.classifier}@exe"
  ))

  inputs.files cfg
  inputs.files protoFiles

  outputs.file out

  doFirst {
    delete out
    if (!protoFiles.empty) {
      exec {
        commandLine = [
          cfg.singleFile,
          "--include_source_info",
          //"--dependency_out=$buildDir/grpc-dep.txt",
          //"--include_imports",
          "--descriptor_set_out=${relativePath(project, out)}"
        ]
        commandLine += "-I${relativePath(project, protoDir)}"
        commandLine += protoFiles.collect { "${relativePath(protoDir, it)}" }
        logger.lifecycle("> ${commandLine.join(' ')}")
      }
    }
  }

  clean.doFirst {
    delete out
  }
}



subprojects {

  apply plugin: "com.satori.transform"
  apply plugin: "com.satori.codegen"
  apply plugin: "com.satori.composer"

  apply plugin: "idea"
  idea {
    module {
      inheritOutputDirs = false
      outputDir = file("$buildDir/idea")
      testOutputDir = file("$buildDir/idea-tests")
    }
  }

  apply plugin: "java"

  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8

  ext {
    pckg = "${project.parent.pckg}.${fmtDotNotation(project.name)}"
    pckgDir = pckg.replace('.', '/')
  }

  sourceSets.main.java.srcDirs = ['src']
  sourceSets.main.resources.srcDirs = ['res']
  sourceSets.test.java.srcDirs = ['tests/src']
  sourceSets.test.resources.srcDirs = ['tests/res']

  compileJava {
    /*inputs.property("moduleName", moduleName)
    doFirst {
      options.compilerArgs = [
        '--module-path', classpath.asPath,
      ]
      classpath = files()
    }*/
  }

  compileTestJava {
    /*inputs.property("moduleName", moduleName)
    doFirst {
      options.compilerArgs = [
        '--module-path', classpath.asPath,
        '--add-modules', 'junit',
        '--add-reads', "$moduleName=junit",
        '--patch-module', "$moduleName=" + files(sourceSets.test.java.srcDirs).asPath,
      ]
      classpath = files()
    }*/
  }

  test {
    /*inputs.property("moduleName", moduleName)
    doFirst {
      jvmArgs = [
        '--module-path', classpath.asPath,
        '--add-modules', "ALL-MODULE-PATH",
        '--add-reads', "$moduleName=junit",
        '--patch-module', "$moduleName=" + files(sourceSets.test.java.outputDir).asPath,
      ]
      classpath = files()
    }*/
  }

  apply plugin: "kotlin"

  kotlin {
    experimental {
      coroutines 'enable'
    }
  }

  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
      jvmTarget = JavaVersion.VERSION_1_8
    }
  }

  sourceSets.main.kotlin.srcDirs = sourceSets.main.java.srcDirs
  sourceSets.test.kotlin.srcDirs = sourceSets.test.java.srcDirs

  // TODO: fix it
  compileKotlin {
    compileJava.dependsOn it
    destinationDir = compileJava.destinationDir
  }
  compileTestKotlin {
    compileTestJava.dependsOn it
    destinationDir = compileTestJava.destinationDir
  }

  task createDefaultProjectStructure {
    group 'codegen'
    doLast {
      println "creating default project structure for project '${project.name}'..."

      // create directories for all source sets
      sourceSets.forEach { sourceSet ->
        sourceSet.java.srcDirs.forEach {
          def pathToCreate = new File(it, pckgDir)
          println "creating sources path for '${sourceSet.name}': '$pathToCreate'"
          pathToCreate.mkdirs()
        }
        sourceSet.resources.srcDirs.forEach {
          def pathToCreate = new File(it, pckgDir)
          println "creating resources path for '${sourceSet.name}': '$pathToCreate'"
          pathToCreate.mkdirs()
        }
      }

      // generate build.gradle
      if (!file("build.gradle").exists() && file("build.template.gradle").exists()) {
        println "creating build.gadle: '${file('build.gradle')}'"
        transform {
          template = rootProject.file('build.template.gradle')
          output = file('build.gradle')
        }
      }
    }
  }

  sourceSets.all { sourceSet ->
    def n = sourceSet.name
    n = n != "main" ? n.capitalize() : ""
    def taskName = "generate${n}Code"
    println "defining task: '${project.name}:${taskName}'"
    def t = task "generate${n}Code"() {
      group 'codegen'
    }
    tasks["compile${n}Java"].dependsOn t
    tasks["compile${n}Kotlin"].dependsOn t
  }

  task generateProtoDescriptorSet {
    group "codegen"
    dependsOn rootProject.extractProtos

    def out = file("$buildDir/grpc.pb")
    def protoDir = file("grpc")
    def protoFiles = fileTree(protoDir) {
      include "**/*.proto"
    }
    def incDir = rootProject.file("grpc/include")

    def cfg = project.configurations.detachedConfiguration()
    cfg.dependencies.add(dependencies.create(
      "com.google.protobuf:protoc:3.5.1:${osdetector.classifier}@exe"
    ))

    inputs.files cfg
    inputs.files protoFiles

    outputs.file out
    outputs.dir file("gen/types")

    sourceSets.main.java.srcDir file("gen/types")

    doFirst {
      delete out
      delete file("gen/types")
      if (!protoFiles.empty) {
        file("gen/types").mkdirs()
        exec {
          commandLine = [
            cfg.singleFile,
            "--include_source_info",
            //"--dependency_out=$buildDir/grpc-dep.txt",
            //"--include_imports",
            "--descriptor_set_out=${relativePath(out)}"
          ]
          commandLine += "-I\"${relativePath(incDir)}\""
          commandLine += "-I\"${relativePath(protoDir)}\""
          commandLine += protoFiles.collect { "\"${relativePath(protoDir, it)}\"" }
          logger.lifecycle("> ${commandLine.join(' ')}")
        }
        exec {
          commandLine = [
            cfg.singleFile,
            "--java_out=gen/types"
          ]
          commandLine += "-I${relativePath(projectDir, incDir)}"
          commandLine += "-I${relativePath(projectDir, protoDir)}"
          commandLine += protoFiles.collect { relativePath(protoDir, it) }
          logger.lifecycle("> ${commandLine.join(' ')}")
        }
      }
    }

    clean.doFirst {
      delete out
      delete file("gen/types")
    }
  }

  repositories {
    jcenter()
    mavenCentral()
    maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
  }

  dependencies {
    compile "org.slf4j:slf4j-api:$slf4jVersion"
    compile "org.slf4j:slf4j-jdk14:$slf4jVersion"
    compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlinVersion"
    compile "org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlinCoroutinesVersion"

    compile satoriLibsVertxKotlin()
    compile satoriLibsAsyncKotlin()
    compile satoriLibsCommonKotlin()

    compile "io.vertx:vertx-core:$vertxVersion"
    compile "io.vertx:vertx-codegen:$vertxVersion"
    //compile "io.vertx:vertx-rx-java:$vertxVersion"
    compile "io.vertx:vertx-service-proxy:$vertxVersion"
    compile "io.vertx:vertx-service-discovery:$vertxVersion"
    compile "io.vertx:vertx-hazelcast:$vertxVersion"

    compile "com.google.dagger:dagger:$daggerVersion"
    compile "com.google.errorprone:error_prone_core:$errorProneVersion"

    compile "com.google.protobuf:protobuf-java:$protobufVersion"

  }
}